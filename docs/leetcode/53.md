---
title: 53、最大子序列和
date: 2021-01-13
sidebar: 'auto'
tags: 
  - 算法leetcode
categories:
  - 算法leetcode
---
[最大子序列和](https://leetcode-cn.com/problems/longest-common-prefix/)

`
执行结果： 通过 显示详情 执行用时： 80 ms , 在所有 JavaScript 提交中击败了 95.05% 的用户 内存消耗： 39.2 MB , 在所有 JavaScript 提交中击败了 66.22% 的用户
`

## 解法

`执行用时： 76 ms , 在所有 JavaScript 提交中击败了 93.33% 的用户 `  
`内存消耗： 37.2 MB , 在所有 JavaScript 提交中击败了 99.20% 的用户`

- 利用栈。  
    - 遇到左括号，一律推入栈中，  
    - 遇到右括号，将栈顶部元素拿出，如果不匹配则返回 false，如果匹配则继续循环。  

    - 为了提高性能, 在循环前进行这一步：let len = s.length是非常关键的，减少了计算次数。  
    - 为了提高执行时间，这一步if (len%2) return false是非常关键的，减少了不必要的计算。  

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    if (!strs) return ''
    if (strs.length === 0) return ''
    if (strs.length === 1) return strs[0]
    let res = dynamicStr = '', first = strs[0];
    let tempStr = ','+strs.join(',')

    for (let i = 0; i < first.length; i ++) {
        let item = first[i]
        dynamicStr += item
        let reg = new RegExp(',' + dynamicStr + '[a-z]*', 'g')
        let matchs = tempStr.match(reg)
        if (matchs && matchs.length !== strs.length) {
            break
        } else {
            res = dynamicStr
        }
    }
    return res
};
```
