---
title: Hooks和react-redux使用及源码
date: 2021/2/5
tags:
 - Hooks
categories:
 - react
sidebar: 'auto'
---
### **本节重点**
::: warning
1. Hooks⽅法
2. ⾼阶组件
3. react-redux使⽤和原理
:::

## 资源
1. [React Redux API](https://www.redux.org.cn/docs/react-redux/api.html)
2. [react-redux github源码](https://github.com/reduxjs/react-redux)
3. [react-router⽂档地址](http://react-router.docschina.org/)

## Hooks API
### useReducer
```jsx
const [state, dispatch] = useReducer(reducer, initialArg, init);
```
[useState](https://zh-hans.reactjs.org/docs/hooks-reference.html)的替代⽅案。它接收⼀个形如 (state, action) => newState 的 reducer，并返回当前
的 state 以及与其配套的 dispatch ⽅法。
```jsx
import React, {useReducer, useLayoutEffect, useEffect} from "react";
import {counterReducer} from "../store";

const init = initArg => {
  return initArg - 0;
};

export default function HooksPage(props) {
  const [state, dispatch] = useReducer(counterReducer, "0", init);

  useEffect(() => {
    console.log("useEffect"); //sy-log
  });

  useLayoutEffect(() => {
    console.log("useLayoutEffect"); //sy-log
  });

  return (
    <div>
      <h3>HooksPage</h3>
      <p>{state}</p>
      <button onClick={() => dispatch({type: "ADD"})}>add</button>
    </div>
  );
}
```
### useEffect
```jsx
useEffect(didUpdate);
```
该 Hook 接收⼀个包含命令式、且可能有副作⽤代码的函数。

在函数组件主体内（这⾥指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录⽇志以及执⾏其他包含副作⽤的操作都是不被允许的，因为这可能会产⽣莫名其妙的 bug 并破坏 UI 的⼀致性。  
使⽤ useEffect 完成副作⽤操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后延迟执⾏。你可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃⽣通道。  
默认情况下，effect 将在每轮渲染结束后执⾏，但你可以选择让它 `在只有某些值改变的时候` 才执⾏。

官⽹地址： [https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect](https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect)

### useLayoutEffect

其函数签名与 `useEffect` 相同，但它会在所有的 DOM 变更之后同步调⽤ `effect`。可以使⽤它来读取
DOM 布局并同步触发重渲染。在浏览器执⾏绘制之前， `useLayoutEffect` 内部的更新计划将被同步
刷新。
尽可能使⽤标准的 `useEffect` 以避免阻塞视觉更新。

## 使⽤react-redux
每次都重新调⽤render和getState太low了，想⽤更react的⽅式来写，需要react-redux的⽀持。
```bash
yarn add react-redux
```
提供了两个api
1. Provider 为后代组件提供store
2. connect 为组件提供数据和变更⽅法

## API
**`<Provider store>`**

`<Provider store>` 使组件层级中的 `connect()` ⽅法都能够获得 Redux store。正常情况下，你的根
组件应该嵌套在 `<Provider>` 中才能使⽤ `connect()` ⽅法。

**`connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])`**

连接 React 组件与 Redux store。  
返回⼀个新的已与 Redux store 连接的组件类。

参数
- `mapStateToProps(state, [ownProps]): stateProps ]` (Function)该回调函数必须返回⼀个纯对象，这个对象会与组件的 props 合并。  
    如果定义该参数，组件将会监听 Redux store 的变化，否则 不监听。  
    ownProps 是当前组件⾃身的props，如果指定了，那么只要组件接收到新的props， mapStateToProps 就会被调⽤，mapStateToProps 都会被重新计算， mapDispatchToProps 也会被调⽤。**注意性能！**  
- `mapDispatchToProps(dispatch, [ownProps]): dispatchProps ]` (Object or Function):
    如果你省略这个 mapDispatchToProps 参数，默认情况下， dispatch 会注⼊到你的组件 props中。  
    如果传递的是⼀个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，对象所
    定义的⽅法名将作为属性名；每个⽅法将返回⼀个新的函数，函数中 dispatch ⽅法会将action creator的返回值作为参数执⾏。这些属性会被合并到组件的 props 中。
    如果传递的是⼀个函数，该函数将接收⼀个 dispatch 函数，然后由你来决定如何返回⼀个对象。  
    ownProps 是当前组件⾃身的props，如果指定了，那么只要组件接收到新的props， mapDispatchToProps 就会被调⽤。**注意性能！**
- `mergeProps(stateProps, dispatchProps, ownProps): props ] `(Function)
  如果指定了这个参数， `mapStateToProps()` 与 `mapDispatchToProps()` 的执⾏结果和组件⾃身的 `props` 将传⼊到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。你也许可以⽤这个回调函数，根据组件的 props 来筛选部分的 `state` 数据，或者把 `props` 中的某个特定变量与 `action creator` 绑定在⼀起。如果你省略这个参数，默认情况下返回`Object.assign({}, ownProps, stateProps, dispatchProps)` 的结果。

全局提供store，index.js
```jsx
import React from "react";
import ReactDOM from "react-dom";
import "./index.css";
import App from "./App";
// import {Provider} from "react-redux";
import {Provider} from "./ReactRedux";
import store from "./store/";

// 把Provider放在根组件外层，使⼦组件能获得store
ReactDOM.render(
  <Provider store={store}>
     <App />
  </Provider>,
  document.getElementById("root")
);
```

获取状态数据，ReactReduxPage.js
```jsx
import React, { Component } from "react";
import { connect } from "react-redux";
class ReactReduxPage extends Component {
  render() {
    const { num, add, minus, asyAdd } = this.props;
    return (
      <div>
        <h1>ReactReduxPage</h1>
        <p>{num}</p>
        <button onClick={add}>add</button>
        <button onClick={minus}>minus</button>
      </div>
    );
  }
}

const mapStateToProps = state => {
  return {
    num: state,
  };
};

const mapDispatchToProps = {
  add: () => {
    return { type: "add" };
  },
  minus: () => {
    return { type: "minus" };
  }
};

export default connect(
  mapStateToProps, //状态映射 mapStateToProps
  mapDispatchToProps, //派发事件映射
)(ReactReduxPage);
```
> connect中的参数：state映射和事件映射

详细使⽤
```jsx
import React, {Component} from "react";
// import {connect} from "react-redux";
// import {bindActionCreators} from "redux";
import {bindActionCreators, connect} from "../ReactRedux";
// connect⽤于连接React组件与store， 返回⼀个新的已经与store连接的组件类（HOC）
export default connect(
  // mapStateToProps Fucntion
  // !慎重定义ownProps，因为你⼀旦定义ownProps，那么每当ownProps发⽣改变的时候，当前的mapStateToProps都会被调⽤，
  // !这⾥的state也会被重新计算，容易影响性能
  state => {
    // console.log("mapStateToProps"); //sy-log
    return {
      count: state
    };
  },
  // mapDispatchToProps Object Fucntion
  // Object 此时props中没有dispacth，但是有action creators，内部实现dispatch
  // {
  //   add: () => ({type: "ADD"}),
  //   minus: () => ({type: "MINUS"})
  // }
  // Fucntion 参数是dispatch与ownProps
  // !慎重定义ownProps，因为你⼀旦定义ownProps，那么每当ownProps发⽣改变的时候，当前的mapStateToProps都会被调⽤，容易影响性能
  (dispatch, ownProps) => {
    console.log("mapDispatchToProps--", ownProps); //sy-log
    let creators = {
      add: payload => ({type: "ADD", payload}),
      minus: () => ({type: "MINUS"})
    };
    creators = bindActionCreators(creators, dispatch);
    return {dispatch, ...creators};
  }
)(
 class ReactReduxPage extends Component {
    add = () => {
      this.props.dispatch({type: "ADD"});
    };
    render() {
      console.log("props", this.props); //sy-log
      const {count, dispatch, add, minus} = this.props;
      return (
        <div>
          <h3>ReactReduxPage</h3>
          <p>omg:{count}</p>
          <button onClick={this.add}>add-use dispatch</button>
          <button onClick={() => add(100)}> add</button>
          <button onClick={minus}>minus</button>
        </div>
      );
    }
 }
);
```

## 实现react-redux
实现React-redux.js
```jsx
import React, {
  useContext,
  useEffect,
  useReducer,
  useState,
  useCallback,
  useLayoutEffect
} from "react";
// 通过Context传递store
// *step1 创建⼀个Context对象
const Context = React.createContext();

// *step2 通过Provider组件传递value（store）
export function Provider({store, children}) {
  return <Context.Provider value={store}>{children}</Context.Provider>;
}

// *step3 ⼦组件接收 context value (Consumser\contextType\useContext)
// ⽅法1 connect
// hoc 函数，参数是组件，返回值是个新组件
export const connect = (
  mapStateToProps = state => state,
  mapDispatchToProps
) => WrappedComponent => props => {
  const store = useContext(Context);
  const {getState, dispatch, subscribe} = store;

  // store state
  const stateProps = mapStateToProps(getState());
  let dispatchProps = {dispatch};
  if (typeof mapDispatchToProps === "object") {
    dispatchProps = bindActionCreators(mapDispatchToProps, dispatch);
  } else if (typeof mapDispatchToProps === "function") {
    dispatchProps = mapDispatchToProps(dispatch);
  }

  // 让函数强制更新的⽅法
  // const [, forceUpdate] = useReducer(x => x + 1, 0);
  // const [, forceUpdate] = useState({});
  const forceUpdate = useForceUpdate();

  // * useEffect _ _ DOM变更 effect执⾏(订阅)
  // * useLayoutEffect __ DOM变更-effect执⾏(订阅)
  // 订阅
  //
  useLayoutEffect(() => {
    //有订阅 ⼀定要有取消订阅
    const unsubscribe = store.subscribe(() => {
      // todo 让函数组件更新
      forceUpdate();
    });
    return () => {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, [store]);

  return <WrappedComponent {...props} {...stateProps} {...dispatchProps} />;
};
// hook只能⽤在函数组件或者是⾃定义hook
function useForceUpdate() {
  const [state, setState] = useState(0);
  const update = useCallback(() => {
    setState(prev => prev + 1);
  }, []);
  return update;
}

function bindActionCreator(creator, dispatch) {
  return (...args) => dispatch(creator(...args));
}

export function bindActionCreators(creators, dispatch) {
  let obj = {};
  // todo
  for (let key in creators) {
    obj[key] = bindActionCreator(creators[key], dispatch);
  }
  return obj;
}
```

## react-redux hooks API及实现
useSelector 获取store state  
useDispatch 获取dispatch
```jsx
import React, {useCallback} from "react";
import {useSelector, useDispatch} from "react-redux";
export default function ReactReduxHookPage({value}) {
  const dispatch = useDispatch();
  const add = useCallback(() => {
    dispatch({type: "ADD"});
  }, []);
  const count = useSelector(({count}) => count);
  return (
    <div>
      <h3>ReactReduxHookPage</h3>
      <p>{count}</p>
      <button onClick={add}>add</button>
    </div>
  );
}
```
实现：
```jsx
export function useSelector(selector) {
  const store = useStore();
  const {getState, subscribe} = store;
  const selectedState = selector(getState());
  const [ignored, forceUpdate] = useReducer(x => x + 1, 0);
  useLayoutEffect(() => {
    const unsubscribe = store.subscribe(() => {
      forceUpdate();
    });
    return () => {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, [store]);
  return selectedState;
}
export function useDispatch() {
  const store = useStore();
  return store.dispatch;
}
export function useStore() {
  const store = useContext(Context);
  return store;
}
```
::: tip
拓展  
**function组件中有类似 forceUpdate 的东⻄吗？**
如果前后两次的值相同， `useState` 和 `useReducer` Hook 都会放弃更新。原地修改 state 并调
⽤ `setState` 不会引起重新渲染。 
通常，你不应该在 React 中修改本地 state。然⽽，作为⼀条出路，你可以⽤⼀个增⻓的计数器来在 state 没变的时候依然强制⼀次重新渲染：
```jsx
const [ignored, forceUpdate] = useReducer(x => x + 1, 0);
function handleClick() {
  forceUpdate();
}
```
可能的话尽量避免这种模式。
:::

## react-router简介
`react-router`包含3个库，`react-router`、`react-router-dom`和`react-router-native`。  
`react-router`提供最基本的路由功能，实际使⽤的时候我们不会直接安装`react-router`，⽽是根据应⽤运⾏的环境选择安装
`react-router-dom`（在浏览器中使⽤）或`react-router-native`（在rn中使⽤）。`react-router-dom`和
`react-router-native`都依赖`react-router`，所以在安装时，`react-router`也会⾃动安装，创建web应⽤，
使⽤：
### 安装
```bash
yarn add react-router-dom
```
### 基本使⽤
react-router中奉⾏⼀切皆组件的思想，路由器-**Router**、链接-**Link**、路由-**Route**、独占-**Switch**、重定向-**Redirect**都以组件形式存在

创建RouterPage.js
```jsx
import React, { Component } from "react";
import { BrowserRouter, Link, Route } from "react-router-dom";
import HomePage from "./HomePage";
import UserPage from "./UserPage";

export default class RouterPage extends Component {
  render() {
    return (
      <div>
        <h1>RouterPage</h1>
        <BrowserRouter>
          <nav>
            <Link to="/">⾸⻚</Link>
            <Link to="/user">⽤户中⼼</Link>
          </nav>
          {/* 根路由要添加exact，实现精确匹配 */}
          <Route exact path="/" component={HomePage} />
          <Route path="/user" component={UserPage} />
        </BrowserRouter>
      </div>
    );
  }
}
```
### 使⽤Router
**404⻚⾯**
设定⼀个没有path的路由在路由列表最后⾯，表示⼀定匹配
```jsx
{/* 添加Switch表示仅匹配⼀个*/}
<Switch>
  {/* 根路由要添加exact，实现精确匹配 */}
  <Route exact path="/" component={HomePage} />
  <Route path="/user" component={UserPage} />
  <Route path="/search/:id" component={Search} />
  <Route render={() => <h1>404</h1>} />
</Switch>
```